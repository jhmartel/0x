<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Zero Subset Sums and Laurent Polynomials</h1><p class="page-description">We have an idea about computing zero subset sums using Laurent polynomials and symbolic calculators. Essentially expanding powers of Laurent polynomials is computationally equivalent to sampling subsets of integers. It's trivial, but it's something useful that we've used with Mathematica and here with SymPy. There's an idea here which we probably learned from Dror Bar-Natan's Shameless Mathematica course and his categorical construction of Khovanov homology, Alexander polynomials, and Euler characteristics, etc..You can do alot with trivial observations!</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2023-01-15T00:00:00-06:00" itemprop="datePublished">
        Jan 15, 2023
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">JHM</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      5 min read
    
</span></p>

    

    
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2023-01-15-PolynomialSubsetSums.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="https://colab.research.google.com/github/jhmartel/fp/blob/master/_notebooks/2023-01-15-PolynomialSubsetSums.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab" /></a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Here we collect some elementary observations on zero sum problems using symbolic calculators. This post is not complete. We simply want to demonstrate <em>how</em> to use polynomials in the style of generating functions to compute zero sums. [-JHM]</em></p>
<h1 id="Symbolic-Solutions-to-Zero-Sum-Problems">Symbolic Solutions to Zero Sum Problems<a class="anchor-link" href="#Symbolic-Solutions-to-Zero-Sum-Problems"> </a></h1><p>The zero subset sum decision problem is this:</p>
<p><em>Given a generic subset $S\subset \bf{Z}$ decide whether there exists a finite subset $S' \subset S$ which sums to zero.</em></p>
<p>The trouble here is always sampling over the powerset $2^S$ of all subsets of $S$. It's a very large set! Is there a categorical approach to enumerating the powerset? Here enters symbolic algebra, and a simple idea, that the powerset is essentially polynomial algebras.</p>
<p>Given a finite subset $S \subset \mathbf{Z}$, we formally define $$p=p_S(x)=\sum_{s\in S} x^s.$$ Evidently $p_S \in \mathbf{Z}[x, x^{-1}]$ belongs to the ring of Laurent polynomials, and is finitely supported since $\#(S) &lt; +\infty$.</p>
<p>_A trivial observation: the coefficient of the degree zero term $x^0=1$ in the powers $p^k$ of $p=p_S$ for $k=1,2,\ldots, N$ represent solutions to zero sum problems, where $N=\#(S)$._</p>
<p>Remark. There is a distinction between zero sums and zero subset sums. If $S$ has cardinality $\#(S)=N$, then we allow any element $s\in S$ to be used at most $N$ times in the polynomial formulation of the zero sum problem. This is in contrast to the zero subset sum problem, where an element $s\in S$ can occur <em>at most once</em>.</p>
<p>For example $S=\{-2, 1, 3\}$ does not have any strict zero subset sums. However the constant coefficient in $q:=p^3=(x^{-2}+x+x^3)^3$ is nonzero because $-2+1+1=0$. So when we use polynomials to find zero sums, we must slightly expand the statement of the zero subset sum problem to allow for small multiplicity. A priori this small multiplicity is at most the cardinality of the set $N=\#(S)$, and we are supposing (yet to be proved) their computational equivalence.</p>
<p>In the zero subset sum problem, we have nothing except brute-force search over the subsets. There are no shortcuts or hidden information to accelerate the procedure.</p>
<p>This same problem arises with the polynomials. For we begin with an initial set $S$ with Laurent polynomial $p=p_S$. However we need to evaluate the coefficients of powers $q=p^k$ of this polynomial.
<em>But the real issue is that the powers of $p$ are not readily computed a priori. We cannot decide whether the constant coefficient is zero or not zero simply from the definition of $q=p^k$.</em> This can only be decided <em>a posteriori</em> after explicit computation.</p>
<p>As obvious as this last sentence sounds, it's somewhat an open problem for most "logical mathematicians".</p>
<p>Question: Are there any analytical tricks for finding the coefficients of $q=p^k$ ? We know none, except Cauchy Residue formula, but it's not clear this is useful in our case...</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">expand</span> 

<span class="c1"># the indeterminate x.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> 

<span class="c1"># formal Laurent polynomial defined by the subset S.</span>
<span class="k">def</span> <span class="nf">poly</span><span class="p">(</span><span class="n">S</span><span class="p">):</span> 
  <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">S</span><span class="p">])</span>

<span class="c1"># returns the constant coefficient for small powers of p=poly(S):</span>
<span class="k">def</span> <span class="nf">cc</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
  <span class="n">p</span><span class="o">=</span><span class="n">poly</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="n">output</span><span class="o">=</span><span class="p">[];</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">q</span><span class="o">=</span><span class="n">expand</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">output</span><span class="o">+=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
  <span class="c1">#print(&quot;The constant coefficients of the small powers of p(S) are:&quot;)</span>
  <span class="k">return</span> <span class="n">output</span>

<span class="c1"># returns Boolean True or False depending on whether there exists zero sum in S. </span>
<span class="k">def</span> <span class="nf">existsZeroSum</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
  <span class="n">val</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>
  <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cc</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
    <span class="n">val</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">pass</span>
  <span class="k">return</span> <span class="n">val</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
  <span class="n">randomS</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)];</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Random S =&quot;</span><span class="p">,</span> <span class="n">randomS</span><span class="p">,</span> <span class="s2">&quot;has a zero subset sum:&quot;</span><span class="p">,</span> <span class="n">existsZeroSum</span><span class="p">(</span><span class="n">randomS</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Random S = [-78, -126, -75, 121, 59, -69] has a zero subset sum: False 

Random S = [-126, -101, -25, -153, 47, -23] has a zero subset sum: True 

Random S = [-80, -104, -113, -81, -150, -161] has a zero subset sum: False 

Random S = [-83, -31, 67, 115, 25, -36] has a zero subset sum: True 

Random S = [79, 74, -13, 168, 89, 150] has a zero subset sum: False 

Random S = [-132, -160, -196, 153, 52, 58] has a zero subset sum: False 

</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It's interesting to remark how the above algorithm loses information, i.e. it solves a decision problem, but does not immediately produce the actual solutions to the zero sum problem. When existsZeroSum returns True, it would be useful to also have the specific subset printed . This is work in progress.</p>
<h1 id="To-Do-List:"><em>To Do List:</em><a class="anchor-link" href="#To-Do-List:"> </a></h1><ul>
<li>Interpret Meet-In-The-Middle for polynomial form of zero sum problem.</li>
<li>What is application of Cauchy-Laurent residue formulas for evaluating coefficients?</li>
<li>Prove or Disprove computational equivalence of discrete and polynomial subset sum problem.</li>
<li>When existsZeroSum($S$)=True, return explicit zero sum $S'$.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Zero-Sums-with-Small-Coefficients:-Computationally-Equivalent?">Zero Sums with Small Coefficients: Computationally Equivalent?<a class="anchor-link" href="#Zero-Sums-with-Small-Coefficients:-Computationally-Equivalent?"> </a></h1><p>Given a subset $S\subset \bf{Z}$ we are looking for coefficients $\epsilon$ satisfying $$\sum_{s\in S} \epsilon(s).s=0$$</p>
<ul>
<li><p>In the classical discrete zero subset sum problem, the coefficients $\epsilon$ satisfy $\epsilon \in \{0, 1\}$.</p>
</li>
<li><p>In the polynomial form of the zero sum problem, the coefficients $\epsilon$ satisfy $\epsilon\in \{0,1,2,\ldots, \#(S)\}$.</p>
</li>
<li><p>Linear algebra and the linear dependance relations implies there exists infinitly many solutions to zero sum equation with coefficients satisfying $\epsilon \in \bf{N}_{\geq 0}$ and $\epsilon \in \bf{Z}$.</p>
</li>
</ul>
<p>It's interesting to contrast the computational complexity of the zero sum equation in each case.</p>
<p>In our discussions we are effectively assuming a positive answer to the following question, although we must admit that we do not yet have a rigorous proof.</p>
<p><em>Question: Does the discrete zero subset sum problem have the same computational complexity as the "polynomial form" of the zero subset problem?</em></p>
<p>Again the difference between the two problems is that we allow coefficients with small multiplicity, namely $\epsilon\in \{0,1,\ldots, \#(S)\}$.</p>

</div>
</div>
</div>
</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="jhmartel/fp"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/fp/2023/01/15/PolynomialSubsetSums.html" hidden></a>
</article>
