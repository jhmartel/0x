{
  
    
        "post0": {
            "title": "Positronium Part I.",
            "content": ". Today we begin the study of Weber&#39;s potential in the isolated two-body system consisting of an electron and positron pair $e^-$ and $e^+$. We assume the particles $e^ pm$ have equal mass $m=m_{e^{ pm}}$. The reduced mass is concentrated at the centre-of-mass $ mu=m/2$. . Weber&#39;s force is attractive between the pair $e^ pm$ at all distances. . The particles $e^ pm$ do not indefinitely spiral inwards. Simulations indicate that the radial distance between $e^ pm$ stays strictly bounded between two upper and lower limits $$0 &lt; r_{lower} leq r leq r_{upper} &lt; + infty .$$ This is rigorously proved in Weber-Clemente, 1990.pdf). . If the electron is indivisible particle, then the above two-body problem models a pair $e^-$ and $e^+$ of isolated electron and positron. . But do the particles $e^ pm$ ever &#39;collide&#39; and annihalate? . In the standard physics textbooks, it seems well known that annihalation between $e^ pm$ occurs and two gamma rays are ejected in opposite directions when $e^ pm$. conserving momentum, etc., and converting all their mass into energy. Thus it&#39;s determined that two gamma rays of energy $0.511 keV$ are released, where Einstein&#39;s formula $E=m_ec^2$ is applied, where $m_e$ is the reduced mass. [ref] The annihalation of $e^ pm$ is apparently an experimental test of the validity of Einstein&#39;s &quot;mass-energy&quot; hypothesis. . But what does Weber&#39;s potential say about the annihalation of $e^+$ and $e^-$ ? . If we know the centre of mass has zero net force, then we can replace the positions $r_1$, $r_2$ of the particles by their relative distance $r_{12}$ from the centre of mass. This yields $$r_1=R + frac{m_2}{m_1+m_2} r_{12}$$ and $$r_2=R - frac{m_1}{m_1+m_2} r_{12}.$$ . Applying Newton&#39;s Second Law that $F_{21}=-F_{12}$ yields the following equation for $r_{12}&#39;&#39;$: $$ mu . r_{12}&#39;&#39; = F_{21},$$ where $ mu$ is the reduced mass of the system, namely $ mu= frac{m_1 m_2}{m_1+m_2}=0.5$. . In the following equations we use numpy.odeint to solve Weber equations of motion of the relative distance $r_{12}$. Therefore we have reduced the two-body problem to a one-body problem. This is a standard reduction. . Given the solution for $r_{12}$, how do we reconstruct the paths/positions of the particles $r_1$, $r_2$ ? Answer: via the relation $r_1=R+ frac{m_2}{m_1+m_2} r_{12}$ and $r_2=R- frac{m_1}{m_1 + m_2}r_{12}$. . Now the relative distance $r_{12}$ is a type of radial distance, and if $r, omega$ is spherical coordinates, then we have $$r&#39;^2=|v|^2= x&#39;^2+y&#39;^2+z&#39;^2=(r&#39;)^2+r^2 ( theta&#39;)^2. $$ The above formula is the usual $|v|^2=v_r^2+v_t^2$, and the tangent velocity $v_t$ satisfies $v_t=r theta&#39;$, where $ theta&#39;$ is the angular velocity. . The conservation of angular momentum says that the angular moment $L= mu r times v$, where $v$ is the linear velocity of $r$, is constant along the motion. Moreover one has $$|L|= mu r^2 theta&#39;.$$ Thus we find the formula $$ theta&#39;= frac{|L|}{ mu r^2}.$$ This implies $$T= frac{ mu}{2}v^2= frac{ mu}{2}[(r&#39;)^2+ frac{|r times v|^2}{r^{2}}]$$ represents the kinetic energy of the system. . The conservation of energy says $T+U$ is constant along trajectories. . # Here we define basic functions. def cross(v1, v2): x1, y1, z1 = v1 x2, y2, z2 = v2 return [y1*z2 - z1*y2, -(x1*z2 - z1*x2), x1*y2 - y1*x2 ] def rho(rel_position): x,y,z = rel_position return (x*x+y*y+z*z)**0.5 def dot(vector1, vector2): x1, y1, z1 = vector1 x2, y2, z2 = vector2 return x1*x2+y1*y2+z1*z2 def rdot(position, vector): return dot(position, vector)/rho(position) def norm(rel_velocity): return rho(rel_velocity) mu=0.5 ## reduced mass of the system. We assume m1 and m2 are equal, hence mu=1/2. c=1.0 ## speed of light constant in Weber&#39;s potential # Define the angular momentum def AngMom(rel_position, rel_velocity): return cross(rel_position, rel_velocity) def L(rel_position, rel_velocity): return norm(cross(rel_position, rel_velocity)) # Linear Kinetic Energy def T(rel_position, rel_velocity): vt = norm(cross(rel_position, rel_velocity)) # next formula decomposes v^2=(vr)^2+(vt)^2, where vt=r*θ&#39;=|L|/(mu*r) return (mu/2)*(rdot(rel_position, rel_velocity)**2) + (mu/2)*(rho(rel_position)**-2)*(vt**2) ## Weber Potential Energy ## Negative sign given -1=q1*q2 def U(rel_position, rel_velocity): x,y,z = rel_position vx,vy,vz = rel_velocity rdot=dot(rel_position, rel_velocity)/rho(rel_position) return -(1/rho(rel_position))*(1-(rdot*rdot)/2) . . import numpy as np from scipy.integrate import odeint, solve_ivp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D ## Integrating two-body isolated system of oppositely charged particles ## i.e. positron+electron pair. ## The product of the charges q1*q2 is factor in Weber&#39;s force law, and appears twice ## in the formula of Newton&#39;s F=ma. def weber(t, rel_state): x, y, z, vx, vy, vz = rel_state r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r A=(-1)*r**-2 ## minus sign from q1*q2 B=1-(rdot*rdot)/2 C=(mu+((c*c*r)**-1))**-1 ## +plus instead of -minus. dxdt = vx dydt = vy dzdt = vz dvxdt = (x/r)*A*B*C dvydt = (y/r)*A*B*C dvzdt = (z/r)*A*B*C return [dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt] t_span = (0.0, 100.0) t = np.arange(0.0, 100.0, 0.1) y1=[2.0,0,0,] # initial relative position v1=[-0.4, 0.4, 0] # initial relative velocity result = odeint(weber, y1+v1, t, tfirst=True) #here odeint solves the weber equations of motion relative y1+v1 for t. Energy=T(y1,v1) + U(y1,v1) print(&#39;The initial total energy T+U is equal to:&#39;, Energy) print(&#39;The initial angular momentum is equal to&#39;, norm(AngMom(y1,v1))) fig = plt.figure() ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;) ax.plot(result[:, 0], result[:, 1], result[:, 2]) ax.set_title(&quot;position&quot;) ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;) ax.plot(result[:, 3], result[:, 4], result[:, 5]) ax.set_title(&quot;velocity&quot;) . The initial total energy T+U is equal to: -0.37999999999999995 The initial angular momentum is equal to 0.8 . Text(0.5, 0.92, &#39;velocity&#39;) . What does the above plot demonstrate? . It reveals a precession motion around the centre of mass. This is not predicted by Coulomb&#39;s force, which bounds the trajectories to elliptical orbits like Newton&#39;s Law of Gravitation. . The force is central, therefore we have conservation of angular momentum, and implies the system is constrained to a plane, namely orthogonal to the angular moment of the system. . Moreover the system satisfies a conservation of linear momentum, namely the sum $T+U$ is constant. . Problem: Verify Assis-Clemente&#39;s 1990 formula for the lower and upper limits of the relative distance along the orbits. | . import matplotlib.pyplot import pylab r_list=[] for j in range(1000): sample_position=[result[j,0], result[j,1], result[j,2]] sample_velocity=[result[j,3], result[j,4], result[j,5]] r_list.append( ( int(j), rho(sample_position) ) ) prelistr = list(zip(*r_list)) pylab.scatter(list(prelistr[0]),list(prelistr[1])) pylab.xlabel(&#39;time&#39;) pylab.ylabel(&#39;rho&#39;) pylab.title(&#39;Solutions have Upper and Lower Limits&#39;) pylab.show() #TU_list=[] #for j in range(1000): # sample_position=[result[j,0], result[j,1], result[j,2]] # sample_velocity=[result[j,3], result[j,4], result[j,5]] # TU_list.append( # (rho(sample_position),T(sample_position,sample_velocity)+U(sample_position, sample_velocity))) #prelist1 = list(zip(*TU_list)) #pylab.scatter(list(prelist1[0]),list(prelist1[1])) #pylab.xlabel(&#39;distance r&#39;) #pylab.ylabel(&#39;T+U&#39;) #pylab.title(&#39;&#39;) #pylab.show() # The plot below demonstrates the conservation of angular momentum. # Note that rdot is directly equal to the sample_velocity. I.e. there is # no need to define rdot=v.hatr/r. This was error. #A_list=[] #for j in range(1000): # sample_position=[result[j,0], result[j,1], result[j,2]] # sample_velocity=[result[j,3], result[j,4], result[j,5]] # A_list.append( # (rho(sample_position), norm(cross(sample_position, sample_velocity)) ) ) #prelist2 = list(zip(*A_list)) #pylab.scatter(list(prelist2[0]),list(prelist2[1])) #pylab.xlabel(&#39;rho&#39;) #pylab.ylabel(&#39;Angular Momentum&#39;) #pylab.title(&#39;Conservation of Angular Momentum&#39;) #pylab.show() #rho_list=[] #for j in range(180): # rho_list.append( # (int(j), rho([result[j,0], result[j,1], result[j,2]]), # ) # ) . . from sympy import * t=symbols(&#39;t&#39;) m=symbols(&#39;m&#39;) c=symbols(&#39;c&#39;) r=Function(&#39;r&#39;)(t) P=Function(&#39;P&#39;)(r,t) F=Function(&#39;F&#39;)(r,t) U=-(r**-1)*(1-((r.diff(t))**2)*(2*c*c)**-1) F=(-1)*(U.diff(t))*((r.diff(t))**-1) pprint(simplify(U)) print() pprint(simplify(F)) ## symbolic computation of the Force law. . . 2 ⎛d ⎞ ⎜──(r(t))⎟ 2 ⎝dt ⎠ - c + ─────────── 2 ────────────────── 2 c ⋅r(t) 2 ⎛d ⎞ 2 ⎜──(r(t))⎟ 2 d ⎝dt ⎠ - c - r(t)⋅───(r(t)) + ─────────── 2 2 dt ─────────────────────────────────── 2 2 c ⋅r (t) .",
            "url": "https://jhmartel.github.io/fp/weber/positronium/two-body/2022/02/22/Positronium_Part1.html",
            "relUrl": "/weber/positronium/two-body/2022/02/22/Positronium_Part1.html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "One-Dimensional Ampere Force",
            "content": ". One-Dimensional Ampere . We continue with our discussion of Ampere&#39;s force, and consider the special case where the current elements are all pairwise parallel and colinear. In otherwords we assume the current elements belong the a line $ ell$ in $ bf{R}^3$. For simplicity we consider the current elements belonging to the $z$-axis. . The state of a current element on the $z$-axis is then represented by a real-valued function $v(x)$ representing the velocity of the current element. Likewise we interpret $|v(x)|$ as the intensity of the current element. Ampere&#39;s force law in the one-dimensional case then becomes: . $$F_{y ~ text{on}~x} =|v(x)|~|v(y)|~v(x)~v(y) ~ nabla_1 ( frac{1}{r}) . $$ . If we integrate the force $F$ over the entire line we obtain $$F_{ text{current on}~ x} = |v(x)|~ v(x) ~[ nabla_1 cdot int dy~ frac{|v(y)| v(y)}{x-y} ]. $$ . The hypothesis of the force being balanced on the line is equivalent to the vanishing $$ nabla_1 ~ int dy frac{|v(y)|~ v(y)}{x-y}= frac{d}{dx} ~ int dy frac{|v(y)|~ v(y)}{x-y}=0 .$$ Equivalently, the force is balanced if the integral $$H(v)(x)=h(x):= int_{- infty}^{+ infty} dy~ frac{|v(y)|~ v(y)}{x-y} $$ is a constant function of $x$ wherever $v(x) neq 0$. . N.B. The integral defining $H(v)$ is taken over the entire real line. We observe that there is no absolute value sign on the denominator $x-y$. This is to include the direction of $ hat{r}$ in the original Ampere law. . Our definition of $H$ is Hilbert&#39;s singular integral transform for real-valued functions. Strictly speaking, the singular integral does not always integrate to a finite number. In the literature, the integral is frequently replaced with a Cauchy principal value. This is related to the function $ frac{1}{y}$ being not absolutely integrable on the real line. However there is sufficient cancellation in the integral to obtain a well-defined principal value. . If the current $v$ is everywhere constant, then symmetry shows the integral $H(v)$ is identically zero, and therefore the total force $F$ of the current is everywhere zero. Therefore we find $v=constant$ is a solution to the balance equation. . N.B. Most discussion of the Hilbert transform is restricted to square-integrable functions on the line $L^2( bf{R})$. On $L^2$ one finds the Hilbert transform defines a unitary operator and is an anti-involution, satisfying $H circ H=-Id$. However the only $L^2$ constant function is the zero function. . Question: Are there any time-independant solutions to the balance equation, i.e. does there exist nonconstant $v in L^ infty( bf{R})$ with $H(v)$ constant? . Question: Can we find time-dependant solutions to the balance equation? I.e. find functions $v_t in L^ infty$ such that $H(v_t)$ is constant for all time $t$. . Remark. The Hilbert transform (modulo homothety) is the only singular operator in one-dimensions which commutes with the affine translation and affine dilatation. This corresponds to the Ampere force commuting with the affine change of variables $x mapsto ax+b$. Since Ampere&#39;s force is relational, it seems proper that the corresponding Hilbert transform also possess these same properties. . Remark. It appears that the only Borel-Radon measures $ mu$ on the real line $ bf{R}$ which have a constant Hilbert transform $H( mu)=c$ are the uniform measures $ mu=const.dy$. If this remains true, then we identify the kernel of $H circ H$ with the uniform measures on $ bf{R}$. .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/18/One_Dimensional_Ampere.html",
            "relUrl": "/fastpages/jupyter/2022/02/18/One_Dimensional_Ampere.html",
            "date": " • Feb 18, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Letter To Prof. Assis.",
            "content": "2022-02-10-Verifying Conservation of Energy with Python. . Dear Professor Assis, . I am currently studying the Weber potential $U= frac{e_1 e_2}{r} (1- frac{r&#39;^2}{2c^2})$ in python, and specifically looking at the equations of motion of an isolated two-body system. For computation i have chosen one particle to be the origin, and look to solve the equations of motion for the second particle. In computations I take $e_1=e_2=1$ and $c=1$, and the relative mass of the second particle to be $m=0.5$. (Is that mass to small?) . I am fairly confident that I have correctly integrated the equations of motion using python&#39;s odeint. . However I am not able to satisfactorily verify conservation of energy $d(T+U)=0$ along the trajectories, and I am not confident that I have the correct expression for kinetic energy $T$, i use the naive expression $T=mv^2/2$, where $v^2$ is computed in usual way as sum of squares of the velocities of the second particle of mass $m=0.5$. When I use the above expression for $T$ I find the sum $T+U$ is not constant along solutions to the equations of motion $mr&#39;&#39;=ma=F$, where $F=- hat{r} frac{dU}{dr}$ is Weber&#39;s force. . From your book on &quot;Relational Mechanics&quot; i understand that kinetic energy is more properly defined as the interaction energy of the particle with the stars at infinity. But is the naive kinetic energy $T=mv^2/2$ the correct expression for the isolated two-body system? . import numpy as np from scipy.integrate import odeint, solve_ivp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D m=0.5 ## mass of second test particle c=1.0 ## speed of light constant in Weber&#39;s potential ## Kinetic Energy: we use the naive expression for vis viva. Is it correct? def T(vx, vy, vz): return m*(vx*vx+vy*vy+vz*vz)/2 ## Weber Potential Energy def U(x,y,z,vx,vy,vz): r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r return (r**-1)*(1-(rdot**2)/2) ## Integrating equations of motion relative Weber&#39;s Force Law. ## I think I have implemented everything correctly. The formula for rdot is from Relational Mechanics, pp.168 ## but perhaps I have the wrong formula for r&#39;&#39; and have not applied Newtons second law F=mr&#39;&#39; correctly? def weber(t, state): x, y, z, vx, vy, vz = state r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r A=r**-2 B=1-(rdot*rdot)/2 C=(m-((c*c*r)**-1))**-1 dxdt = vx dydt = vy dzdt = vz dvxdt = (x/r)*A*B*C dvydt = (y/r)*A*B*C dvzdt = (z/r)*A*B*C return [dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt] t_span = (0.0, 40.0) t = np.arange(0.0, 40.0, 0.001) y0=[0, 1.2, 0, 0, -0.4, .1] ## initial state of the system y0=[x, y, z, vx, vy, vz] result = odeint(weber, y0, t, tfirst=True) Energy=T(y0[3], y0[4], y0[5] ) + U(y0[0],y0[1],y0[2],y0[3],y0[4],y0[5]) print(&#39;The initial total energy T+U is equal to:&#39;, Energy) print(&#39;The luminal energy is:&#39;, m*c*c/2) print(&#39;The energy is subliminal:&#39;, Energy &lt; m*c**2 /2) r=(y0[0]*y0[0] + y0[1]*y0[1] + y0[2]*y0[2])**0.5 print(&#39;Webers critical radius is equal to:&#39;,(m*c*c)**-1) print(&#39;The initial radius r is within the Weber critical distance:&#39;, r &lt; (m*c*c)**-1 ) fig = plt.figure() ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;) ax.plot(result[:, 0], result[:, 1], result[:, 2]) ax.set_title(&quot;position&quot;) ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;) ax.plot(result[:, 3], result[:, 4], result[:, 5]) ax.set_title(&quot;velocity&quot;) . The initial total energy T+U is equal to: 0.8091666666666666 The luminal energy is: 0.25 The energy is subliminal: False Webers critical radius is equal to: 2.0 The initial radius r is within the Weber critical distance: True . Text(0.5, 0.92, &#39;velocity&#39;) . import matplotlib.pyplot import pylab def rho(x,y,z): return (x*x+y*y+z*z)**0.5 v_list=[] for j in range(4000): v_list.append( (rho(result[j,0], result[j,1], result[j,2]), T(result[j,3], result[j,4], result[j,5])) ) U_list=[] for j in range(4000): U_list.append( (rho(result[j,0], result[j,1], result[j,2]), U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5])+T(result[j,3], result[j,4], result[j,5])) ) prelist1 = list(zip(*v_list)) pylab.scatter(list(prelist1[0]),list(prelist1[1])) pylab.xlabel(&#39;distance r&#39;) pylab.ylabel(&#39;Kinetic Energy T&#39;) pylab.title(&#39;rT plot&#39;) pylab.show() prelist2 = list(zip(*U_list)) pylab.scatter(list(prelist2[0]),list(prelist2[1])) pylab.xlabel(&#39;distance r&#39;) pylab.ylabel(&#39;T+U&#39;) pylab.title(&#39;Conservation of Energy&#39;) pylab.show() ## Error. Expect to see conservation of energy T+U = constant in the second figure. However the sum T+U appears nonconstant. . Discussion: The horizontal axis is the radial distance $r$ from the origin, and the vertical axis is the energy value. We expect the second figure to be a horizontal straight line. It does appear basically flat except for blow-up behaviour at small distance. Perhaps given the relative size of the interval of integration, namely $0.001$, the total energy $T+U$ is constant within error. . Is this loss/gain of energy a defect from the odeint routine? In otherwords, is energy not conserved because of cumulative errors and approximations in the solution? . for j in range(50): print( U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5]) + T(result[j,3], result[j,4], result[j,5]) ) . 0.8091666666666666 0.8091694528769837 0.8091722560959542 0.8091750763849768 0.8091779137441633 0.8091807683256578 0.8091836401044897 0.8091865291060831 0.8091894353679061 0.8091923589396186 0.8091952998832174 0.8091982582731821 0.8092012341218966 0.8092042274175154 0.8092072382239642 0.8092102666157523 0.8092133126780814 0.8092163765069865 0.8092194582094769 0.8092225578481547 0.8092256753069924 0.8092288106302348 0.8092319638914872 0.8092351351750412 0.8092383245760144 0.8092415322004902 0.8092447570890509 0.8092480017730359 0.8092512645080137 0.8092545454217692 0.8092578446432682 0.8092611623026272 0.8092644985310876 0.8092678534609862 0.809271227118879 0.8092746194540041 0.8092780305448041 0.8092814604679077 0.8092849092969379 0.8092883771024215 0.8092918639517022 0.8092953699088504 0.8092988950345746 0.80930243938613 0.8093060030172264 0.8093095859779383 0.8093131883146094 0.8093168100697619 0.8093204512819989 0.8093241120128701 . Radius of Weber&#39;s Planetary Atomic Model . Now we consider the diameter of Weber&#39;s critical radius if the test particles $x_1$, $x_2$ are equal to a positron, electron pair. . The mass of the electron is: [ref]. . Lagrangian L=T-U . Given the conservation of energy $d(T+U)=0$ it seems natural to consider the so-called Lagrangian $L=T-U$. But what do we expect from this lagrangian? Is there any reason to believe that a &quot;minimum action&quot; principle holds for two-body systems? Does the above naive expression for $L$ actually correspond to a reasonable action functional on the state space? . L_list=[] for j in range(4000): L_list.append( (rho(result[j,0], result[j,1], result[j,2]), -U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5])+T(result[j,3], result[j,4], result[j,5])) ) prelist2 = list(zip(*L_list)) pylab.scatter(list(prelist2[0]),list(prelist2[1])) pylab.show() .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/10/LetterToAssisWeberPotentials.html",
            "relUrl": "/fastpages/jupyter/2022/02/10/LetterToAssisWeberPotentials.html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jhmartel.github.io/fp/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jhmartel.github.io/fp/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jhmartel.github.io/fp/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}