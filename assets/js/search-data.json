{
  
    
        "post0": {
            "title": "Einstein SR and Maxwell",
            "content": ". Einstein SR and Maxwell . The history of SR arose out of Einstein&#39;s study of Maxwell equations, but what is the logical relation between SR and Maxwell? . By Maxwell equations we understand the following: in a given reference frame $K$ we have the existence of electric and magnetic fields $E,B$ satisfying [equations]. Composing the equations yields the fact that the components of $E,B$ satisfy the wave equation with speed of propagation $c= sqrt{ epsilon_0 mu_0}$. The classical homogeneous wave equation has the property of the velocity being dependant on the receiver velocity. But SR rushedly argues that the assumption (A12) on the &quot;rectilinear uniform propagation of light&quot; somehow yields a wave equation where velocity is receiver independant. But how? . Levi-Civita summarizes Einstein&#39;s geometric optics in two equations: first we have $$ds^2=0$$ and $$ delta int ds=0.$$ . Here $$ds^2=-c^2 dt^2 + dx^2+dy^2+dz^2.$$ The Lorentz invariance of $ds^2$ implies the null cone $ds=0$ is Lorentz invariant. Now we discuss several group actions: . First we have $$ rho_0:{ bf{R}}^{1,3} times L to { bf{R}}^{1,3}$$ which is the linear representation $ rho_0$ represented by left multiplication. . Let $C({ bf{R}}^{3,1})$ be the space of functions on the space. Naturally we assemble $C$ from the dual functionals $ lambda in {({ bf{R}}^{3,1})}^*$. Then taking products and polynomials in the dual functions $ lambda$ we obtain the contragradient represention $$ rho_0^*:C( { bf{R}}^{3,1}) times L to C({ bf{R}}^{3,1}). $$ . Abbreviate $C:=C({ bf{R}}^{3,1})$. . Now what are vector fields? . In differential topology, the vector fields $ frac{ partial }{ partial x}$ act on functions as a derivation, i.e. a map $$ frac{ partial }{ partial x}: C to C $$ satisfying Liebniz law. . Iterating the derivations $ frac{ partial }{ partial x} circ frac{ partial }{ partial y}= frac{ partial^2 }{ partial x partial y}$ leads to the usual differential operators. Consider the d&#39;Alembert operator $$ square:= frac{-1}{c^2} frac{ partial^2}{ partial t^2} + frac{ partial^2}{ partial x^2}+ frac{ partial^2}{ partial y^2}+ frac{ partial^2}{ partial z^2} .$$ . Now our main proposal is that the Minkowski squared line element $ds^2$ is dual in a natural linear algebraic sense to the d&#39;Alembert operator $ square$. . The idea is that $V$ and $V^*$ are isomorphic (non canonically) for finite-dimensional vector spaces $V$. Moreover the algebra generated by $V^*$ yields an (infinite-dimensional) space of functions on $V$. . The Lorentz invariance of $ square$ shows the solutions to the homogeneous wave equation (HWE) are Lorentz covariant and $ square phi =0$ if and only if $ square lambda cdot phi =0$ for every Lorentz transformation $ lambda in L$. The corresponding fact for $ds^2$ is that the null cone $ds^2=0$ is Lorentz covariant. . So what have we shown? That the Minkowski line element $ds^2$ is dual to d&#39;Alembert $ square$, and if light is assumed to propagate according to $ds^2=0$, then [incomplete]. . For example, the quadratic form representing $ds^2$ satisfies $ square h=0$ where $h=-c^2t^2+ frac{1}{3}(x^2+y^2+z^2)$. . Now Einstein&#39;s (A12) postulates the uniform rectilinear propagation of light in vacuum. This would suggest a corpuscular model of light, being represented as affine parameterized lines $$s mapsto (s, x(s), y(s), z(s))=(s, gamma(s)) $$ in ${ bf{R}}^{3,1}$ satisfying $D^2_{ss} gamma =0$. . Is the equation $D^2_{ss} gamma=0$ Lorentz covariant? (Yes?) . But what are the corresponding &quot;uniform rectilinear&quot; solutions $ phi$ for the dual HWE: $~~ square phi=0$ ? This would be a Lorentz invariant class of solutions $ { phi }$ of the HWE which have [incomplete: some uniform and rectilinear characteristics]. . Compare https://ccrma.stanford.edu/~jos/pasp/Spherical_Waves_Point_Source.html . Concluding idea: there has always been correspondance between lines in $V$ (one-dimensional linear subspaces) and quadratic functionals via the Segre embedding, or $ lambda mapsto lambda^2$ where $ lambda in V^*$ is a linear functional. . If $v$ belongs to null cone, then $q(x):=h(v,x)^2/2$ for $x in V$ defines a quadratic function on $V$ with $q(v)=h(v,v)^2=0$. It&#39;s clear that $q$ is minimized along $v^ perp$, and that $v in v^ perp$. Moreover the differential of $q(x)=q(t,x)$ satisfies $dq|_x=h(v,x)v$. . The following questions will be answered below: . Are the quadratic functions $q(x)=h(v,x)^2/2$ solutions to $ square =0$ for null vector $v in N$? . | Can we find quadratic functions $q$ whose level sets are everywhere orthogonal to the null cone $N$ ? . | . The idea would be to derive some canonical solutions $ square q=0$ from quadratics arising from vectors on the null cone. . Lemma. For every vector $v in { bf{R}}^{3,1}$, let $q(x):=h(v,x)^2$ be the quadratic form defined by $v$. Then $ square q=0$ if and only if $v in N$ and $h(v,v,)=0$. . Proof. We argue computationally. If $v=[v_t, v_x, v_y, v_z]$, then $h(v,x)^2$ is equal to $$(-v_t t + v_xx+ v_yy+ v_zz)^2,$$ which is equal to $$v_t^2 t^2 +v_x^2 x^2 + v_y^2 y^2 + v_z^2 z^2 + (mixed~ terms).$$ Therefore applying d&#39;Alembert&#39;s operator we find $$ square q =2( -v_t^2+v_x^2 + v_y^2 + v_z^2), $$ and the claim follows. Indeed we have established the general identity $$ square q = 2 h(v,v), $$ whenever $q(x)=h(v,x)^2$. .",
            "url": "https://jhmartel.github.io/fp/einstein/maxwell/wave%20equation/lorentz/sr/2022/02/23/Einstein_Maxwell.html",
            "relUrl": "/einstein/maxwell/wave%20equation/lorentz/sr/2022/02/23/Einstein_Maxwell.html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Positronium Part I.",
            "content": ". [Incomplete Post]Our goal is to study Weber&#39;s potential in the isolated two-body system consisting of an electron and positron pair $e^-$ and $e^+$. We assume the particles $e^ pm$ have equal mass $m=m_{e^{ pm}}$. The reduced mass is concentrated at the centre-of-mass $ mu=m/2$. . Weber&#39;s force is attractive between the pair $e^ pm$ at all distances. . The particles $e^ pm$ do not indefinitely spiral inwards, but simulations indicate that the radial distance between $e^ pm$ stays strictly bounded between two upper and lower limits $$0 &lt; r_{lower} leq r leq r_{upper} &lt; + infty .$$ This is rigorously proved in Weber-Clemente, 1990.pdf). . But do the particles $e^ pm$ ever &#39;collide&#39; and annihalate? In the standard physics textbooks, it seems well known that annihalation between $e^ pm$ occurs and two gamma rays are ejected in opposite directions when $e^ pm$. conserving momentum, etc., and converting all their mass into energy. Thus it&#39;s computed that two gamma rays of energy $0.511 keV$ are released. Here the classical formula $E=m_ec^2$ is applied, where $m_e$ is the reduced mass. [ref] . The annihalation of $e^ pm$ is apparently an experimental test of the validity of Einstein&#39;s &quot;mass-energy&quot; hypothesis. But what does Weber&#39;s potential say about the annihalation of $e^+$ and $e^-$ ? . References for this section: we have used Assis-Clemente [Ibid], and the lecture notes [ref]. . If we know the centre of mass has zero net force, then we can replace the positions $r_1$, $r_2$ of the particles by their relative distance $r_{12}$ from the centre of mass. This yields $$r_1=R + frac{m_2}{m_1+m_2} r_{12}$$ and $$r_2=R - frac{m_1}{m_1+m_2} r_{12}.$$ . Applying Newton&#39;s Second Law that $F_{21}=-F_{12}$ yields the following equation for $r_{12}&#39;&#39;$: $$ mu . r_{12}&#39;&#39; = F_{21},$$ where $ mu$ is the reduced mass of the system, namely $ mu= frac{m_1 m_2}{m_1+m_2}=0.5$. . In the following equations we use odeint to solve Weber equations of motion of the relative distance $r_{12}$. Therefore we have reduced the two-body problem to a one-body problem based only on relative position $r_{12}$ and it&#39;s relative velocity $r_{12}&#39;$ and relative acceleration $r&#39;&#39;_{12}$. . Given the solution for $r_{12}$, how do we reconstruct the paths/positions of the particles $r_1$, $r_2$ ? Answer: via the relation $r_1=R+ frac{m_2}{m_1+m_2} r_{12}$ and $r_2=R- frac{m_1}{m_1 + m_2}r_{12}$. . Now the relative distance $r_{12}$ is a type of radial distance, and if $r, omega$ is spherical coordinates, then we have $$r&#39;^2=|v|^2= x&#39;^2+y&#39;^2+z&#39;^2=(r&#39;)^2+r^2 ( theta&#39;)^2. $$ The above formula is the usual $|v|^2=v_r^2+v_t^2$, and the tangent velocity $v_t$ satisfies $v_t=r theta&#39;$, where $ theta&#39;$ is the angular velocity. . The conservation of angular momentum says that the angular moment $L= mu r times v$, where $v$ is the linear velocity of $r$, is constant along the motion. Moreover one has $$|L|= mu r^2 theta&#39;.$$ Thus we find the formula $$ theta&#39;= frac{|L|}{ mu r^2}.$$ This implies $$T= frac{ mu}{2}v^2= frac{ mu}{2}[(r&#39;)^2+ frac{|r times v|^2}{r^{2}}]$$ represents the kinetic energy of the system. . The conservation of energy says $T+U$ is constant along trajectories. . import numpy as np from scipy.integrate import odeint, solve_ivp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def cross(v1, v2): x1, y1, z1 = v1 x2, y2, z2 = v2 return [y1*z2 - z1*y2, -(x1*z2 - z1*x2), x1*y2 - y1*x2 ] def rho(rel_position): x,y,z = rel_position return (x*x+y*y+z*z)**0.5 def dot(vector1, vector2): x1, y1, z1 = vector1 x2, y2, z2 = vector2 return x1*x2+y1*y2+z1*z2 def rdot(position, vector): return dot(position, vector)/rho(position) def norm(rel_velocity): return rho(rel_velocity) mu=0.5 ## reduced mass of the system. We assume m1 and m2 are equal, hence mu=1/2. c=1.0 ## speed of light constant in Weber&#39;s potential # Define the angular momentum def AngMom(rel_position, rel_velocity): return cross(rel_position, rel_velocity) def L(rel_position, rel_velocity): return norm(cross(rel_position, rel_velocity)) # Linear Kinetic Energy def T(rel_position, rel_velocity): vt = norm(cross(rel_position, rel_velocity)) # next formula decomposes v^2=(vr)^2+(vt)^2, where vt=r*θ&#39;=|L|/(mu*r) return (mu/2)*(rdot(rel_position, rel_velocity)**2) + (mu/2)*(rho(rel_position)**-2)*(vt**2) ## Weber Potential Energy ## Negative sign given -1=q1*q2 def U(rel_position, rel_velocity): x,y,z = rel_position vx,vy,vz = rel_velocity rdot=dot(rel_position, rel_velocity)/rho(rel_position) return -(1/rho(rel_position))*(1-(rdot*rdot)/2) ## Integrating two-body isolated system of oppositely charged particles ## i.e. positron+electron pair. ## the product of the charges q1*q2 is factor in Weber&#39;s force law, and appears twice ## in the formula of Newton&#39;s F=ma. def weber(t, rel_state): x, y, z, vx, vy, vz = rel_state r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r A=(-1)*r**-2 ## minus sign from q1*q2 B=1-(rdot*rdot)/2 C=(mu+((c*c*r)**-1))**-1 ## +plus instead of -minus. dxdt = vx dydt = vy dzdt = vz dvxdt = (x/r)*A*B*C dvydt = (y/r)*A*B*C dvzdt = (z/r)*A*B*C return [dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt] t_span = (0.0, 100.0) t = np.arange(0.0, 100.0, 0.1) #y0=[20,0,0, 1.2, .2, 0.2] ## initial state of the system y0=[x, y, z, vx, vy, vz] y1=[2.0,0,0,] v1=[-0.4, 0.4, 0] result = odeint(weber, y1+v1, t, tfirst=True) Energy=T(y1,v1) + U(y1,v1) print(&#39;The initial total energy T+U is equal to:&#39;, Energy) print(&#39;The initial angular momentum is equal to&#39;, norm(AngMom(y1,v1))) fig = plt.figure() ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;) ax.plot(result[:, 0], result[:, 1], result[:, 2]) ax.set_title(&quot;position&quot;) ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;) ax.plot(result[:, 3], result[:, 4], result[:, 5]) ax.set_title(&quot;velocity&quot;) . The initial total energy T+U is equal to: -0.37999999999999995 The initial angular momentum is equal to 0.8 . Text(0.5, 0.92, &#39;velocity&#39;) . import matplotlib.pyplot import pylab r_list=[] for j in range(1000): sample_position=[result[j,0], result[j,1], result[j,2]] sample_velocity=[result[j,3], result[j,4], result[j,5]] r_list.append( ( int(j), rho(sample_position) ) ) prelistr = list(zip(*r_list)) pylab.scatter(list(prelistr[0]),list(prelistr[1])) pylab.xlabel(&#39;time&#39;) pylab.ylabel(&#39;rho&#39;) pylab.title(&#39;Solutions have Upper and Lower Limits&#39;) pylab.show() #TU_list=[] #for j in range(1000): # sample_position=[result[j,0], result[j,1], result[j,2]] # sample_velocity=[result[j,3], result[j,4], result[j,5]] # TU_list.append( # (rho(sample_position),T(sample_position,sample_velocity)+U(sample_position, sample_velocity))) #prelist1 = list(zip(*TU_list)) #pylab.scatter(list(prelist1[0]),list(prelist1[1])) #pylab.xlabel(&#39;distance r&#39;) #pylab.ylabel(&#39;T+U&#39;) #pylab.title(&#39;&#39;) #pylab.show() # The plot below demonstrates the conservation of angular momentum. # Note that rdot is directly equal to the sample_velocity. I.e. there is # no need to define rdot=v.hatr/r. This was error. #A_list=[] #for j in range(1000): # sample_position=[result[j,0], result[j,1], result[j,2]] # sample_velocity=[result[j,3], result[j,4], result[j,5]] # A_list.append( # (rho(sample_position), norm(cross(sample_position, sample_velocity)) ) ) #prelist2 = list(zip(*A_list)) #pylab.scatter(list(prelist2[0]),list(prelist2[1])) #pylab.xlabel(&#39;rho&#39;) #pylab.ylabel(&#39;Angular Momentum&#39;) #pylab.title(&#39;Conservation of Angular Momentum&#39;) #pylab.show() #rho_list=[] #for j in range(180): # rho_list.append( # (int(j), rho([result[j,0], result[j,1], result[j,2]]), # ) # ) . from sympy import * t=symbols(&#39;t&#39;) m=symbols(&#39;m&#39;) c=symbols(&#39;c&#39;) r=Function(&#39;r&#39;)(t) P=Function(&#39;P&#39;)(r,t) F=Function(&#39;F&#39;)(r,t) U=-(r**-1)*(1-((r.diff(t))**2)*(2*c*c)**-1) F=(-1)*(U.diff(t))*((r.diff(t))**-1) pprint(simplify(U)) print() pprint(simplify(F)) ## symbolic computation of the Force law. . 2 ⎛d ⎞ ⎜──(r(t))⎟ 2 ⎝dt ⎠ - c + ─────────── 2 ────────────────── 2 c ⋅r(t) 2 ⎛d ⎞ 2 ⎜──(r(t))⎟ 2 d ⎝dt ⎠ - c - r(t)⋅───(r(t)) + ─────────── 2 2 dt ─────────────────────────────────── 2 2 c ⋅r (t) .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/22/Positronium_Part1.html",
            "relUrl": "/fastpages/jupyter/2022/02/22/Positronium_Part1.html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "One-Dimensional Ampere Force",
            "content": ". One-Dimensional Ampere . We continue with our discussion of Ampere&#39;s force, and consider the special case where the current elements are all pairwise parallel and colinear. In otherwords we assume the current elements belong the a line $ ell$ in $ bf{R}^3$. For simplicity we consider the current elements belonging to the $z$-axis. . The state of a current element on the $z$-axis is then represented by a real-valued function $v(x)$ representing the velocity of the current element. Likewise we interpret $|v(x)|$ as the intensity of the current element. Ampere&#39;s force law in the one-dimensional case then becomes: . $$F_{y ~ text{on}~x} =|v(x)|~|v(y)|~v(x)~v(y) ~ nabla_1 ( frac{1}{r}) . $$ . If we integrate the force $F$ over the entire line we obtain $$F_{ text{current on}~ x} = |v(x)|~ v(x) ~[ nabla_1 cdot int dy~ frac{|v(y)| v(y)}{x-y} ]. $$ . The hypothesis of the force being balanced on the line is equivalent to the vanishing $$ nabla_1 ~ int dy frac{|v(y)|~ v(y)}{x-y}= frac{d}{dx} ~ int dy frac{|v(y)|~ v(y)}{x-y}=0 .$$ Equivalently, the force is balanced if the integral $$H(v)(x)=h(x):= int_{- infty}^{+ infty} dy~ frac{|v(y)|~ v(y)}{x-y} $$ is a constant function of $x$ wherever $v(x) neq 0$. . N.B. The integral defining $H(v)$ is taken over the entire real line. We observe that there is no absolute value sign on the denominator $x-y$. This is to include the direction of $ hat{r}$ in the original Ampere law. . Our definition of $H$ is Hilbert&#39;s singular integral transform for real-valued functions. Strictly speaking, the singular integral does not always integrate to a finite number. In the literature, the integral is frequently replaced with a Cauchy principal value. This is related to the function $ frac{1}{y}$ being not absolutely integrable on the real line. However there is sufficient cancellation in the integral to obtain a well-defined principal value. . If the current $v$ is everywhere constant, then symmetry shows the integral $H(v)$ is identically zero, and therefore the total force $F$ of the current is everywhere zero. Therefore we find $v=constant$ is a solution to the balance equation. . N.B. Most discussion of the Hilbert transform is restricted to square-integrable functions on the line $L^2( bf{R})$. On $L^2$ one finds the Hilbert transform defines a unitary operator and is an anti-involution, satisfying $H circ H=-Id$. However the only $L^2$ constant function is the zero function. . Question: Are there any time-independant solutions to the balance equation, i.e. does there exist nonconstant $v in L^ infty( bf{R})$ with $H(v)$ constant? . Question: Can we find time-dependant solutions to the balance equation? I.e. find functions $v_t in L^ infty$ such that $H(v_t)$ is constant for all time $t$. . Remark. The Hilbert transform (modulo homothety) is the only singular operator in one-dimensions which commutes with the affine translation and affine dilatation. This corresponds to the Ampere force commuting with the affine change of variables $x mapsto ax+b$. Since Ampere&#39;s force is relational, it seems proper that the corresponding Hilbert transform also possess these same properties. . Remark. It appears that the only Borel-Radon measures $ mu$ on the real line $ bf{R}$ which have a constant Hilbert transform $H( mu)=c$ are the uniform measures $ mu=const.dy$. If this remains true, then we identify the kernel of $H circ H$ with the uniform measures on $ bf{R}$. .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/18/One_Dimensional_Ampere.html",
            "relUrl": "/fastpages/jupyter/2022/02/18/One_Dimensional_Ampere.html",
            "date": " • Feb 18, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Weber's Critical Radius, Work, and E=mc2 Formulas",
            "content": ". In the [previous post] we discussed the equations of motion of a charged particle in free fall w.r.t. Weber&#39;s potential $U$. Now we consider the problem of work, and the problem of moving particles &quot;upstream&quot; of the potential. . Recall the Coulomb-type expression that &quot;opposite charges attract&quot; and &quot;like charges repel&quot;. If we arranged some charged particles on a plate, then in a short time these particles would either be repelled outwards to the boundary of the plate or the opposite charges would cancel on the interior. Again this is with respect to the Coulomb model $V(r)=1/r$. . But Weber&#39;s model has the following amazing prediction: &quot;opposite charges attract except at a small critical distance $r=r_c$ where the charges acquires a negative inertial mass and the Weber force becomes repulsive&quot;. Furthermore, &quot;like charges repel except at a small critical distance where the Weber force becomes attractive&quot;. This latter prediction leads to Weber&#39;s *planetary model of the atom&quot;. [Insert ref]. . In the (cgs) units the critical radius $r_c$ is computed as $r_c= frac{1}{m c^2}$ where $m$ is the relative inertial mass of one of the particles. The proof of this formula is an application of Newton&#39;s second law, that $m a = bf{F}$ where $ bf{F}$ is Weber&#39;s force. [insert ref] . Now the question arises: if we have two identical but opposite electrically charged particles, say $(-1)e$ and $(+1)e$, where $e$ is a small mass, then how much work is required to drive $(-1)e$ and $(+1)e$ to within Weber&#39;s critical radius $r_c$? . Weber comments in his final memoir [ref] that an infinite amount of work would be required, however no technical details are provided. In fact this author thinks its evident that a large finite amount of work is required, and the computation of this work required is the subject of this post. . How to compute Work: We imagine a particle moving through a potential $U$ along a trajectory $ gamma.$ Our goal is to determine how much work is required to breach (&quot;pass through&quot;) the critical radius $r_c= frac{1}{mc^2}$ in units where $4 pi epsilon_0 = 1$. . We begin assuming the particle&#39;s trajectory is rectilinear. This means the tangent $ gamma&#39;$ and $ gamma$ are parallel for all values of the parameter. Moreover we can use the Riemannian idea of parameterizing the curve by arclength. Then we ask how much work is required to move the particle through $U$ at a constant rate of speed, namely $|| gamma&#39;||=1$. . Weber&#39;s force is conservative, so there is some path independance, however the terminal conditions are not fixed a priori. It might happen that breaching the Weber radius is easier if the particles velocity is nearly parallel to the &quot;virtual&quot; surface of the Weber&#39;s critical radius. That is to say, the curvature term $r r&#39;&#39;/c^2$ in Weber&#39;s force law might sometimes reduce the work needed, depending on the sign. . In terms of the relational variables recall the useful formula/definition $$ r&#39; = frac{ bf{r} cdot bf{r&#39;}}{r}.$$ In our setting we find $$r&#39;= frac{ gamma cdot gamma&#39;}{|| gamma||}.$$ Applying the Cauchy-Schwartz inequality, we find $$r&#39;=1.$$ I.e. equality is obtained in Cauchy-Schwartz because $ gamma, gamma&#39;$ are parallel by hypothesis and $|| gamma&#39;||=1$. . Moreover the rectilinear motion implies $r&#39;&#39;=0$, i.e. the trajectory has zero curvature, since the direction of the particle does not change. Therefore Weber&#39;s force leads to work being computed by the integral $$W=(1- frac{1}{2c^2}) int_{+ infty}^{r_c} frac{1}{r^2} dr = (1- frac{1}{2c^2})mc^2=mc^2-m/2.$$ So what is the total energy of the above system? The total energy is the work required $mc^2 - m/2$ plus the initial kinetic energy $T_i=m| gamma&#39;|^2/2=m/2$. Therefore the total energy required to breach the Weber critical radius is $E=W+T_i=mc^2$. . N.B. All the while our particles are &quot;travelling upstream&quot;. So the above computation indicates that if a particle is given sufficient energy (i.e. sufficient kinetic energy, then the particle could breach the Weber critical radius, and arriving at the Weber radius with almost zero kinetic energy). . N.B. The integral representing $W$ is parameterization independant. Therefore the work required by the unit-parameterized path is not overly specialized, but represents the general computation. . The above discussion was restricted to rectilinear trajectories. But the possibility remains that curvilinear (&quot;spiralling&quot;) trajectories require less work to breach the Weber radius. Thus while it appears that breaching the Weber radius via rectilinear paths requires large energy $ approx mc^2$, perhaps the spiralling paths -- where the curvature term maintains a definite sign -- are the more interesting. . Problem: Determine the minimum energy required for an isolated two-body system to breach the Weber critical radius. . Answer: The minimum energy required to breach the critical radius is $E=mc^2$. . This is consequence of the fact that $ bf{F}$ is a conservative force, therefore dependant only on the initial and terminal states, and not the path taken. Moreover the work done by a particle traversing a path $ gamma$ depends only on the difference in potential energies. This implies that the above evaluation in the rectilinear case is essentially the same for all paths from some initial point to to within the critical radius. . Is the energy spectrum within the critical radius continuous? (Yes, i think the orbits can have arbitrary energy within the radius). | How to relate Birkeland currents (FFAC) to Weber&#39;s potential? Don Scott considers the plasma cylinder, with a stead current. Then the min energy state has zero internal pressure, therefore the net internal energy of the plasma cylinder needs be minimized, i.e. vanishing. Difficulty: without the Maxwell equations we do not know relationship between the current flow $I d ell=qdv$. This equality is Weber&#39;s hypothesis, i.e. a current flow is equivalent to a charge in motion, where $dv$ represents the instantaneous velocity of the charged particle. |",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/16/WeberEMC2.html",
            "relUrl": "/fastpages/jupyter/2022/02/16/WeberEMC2.html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Phipp's Potential",
            "content": "Here we examine Phipp&#39;s potential $P= frac{1}{r} sqrt{1- frac{r&#39;}{c}}$. It&#39;s clear that Phipp&#39;s potential imposes an upper bound on the velocities of particles in free fall relative to $P$. But while Phipp&#39;s potential guarantees subluminal velocities, it does not appear to satisfy a conservation of energy, and the quantity $T+P$ is not constant along trajectories. . The Phipp potential can induce negative effective mass at small distances, similar to the case of Weber&#39;s potential. However the critical radius depends on the relative velocity of the particles. By contrast Weber&#39;s critical radius depends only on the mass $m$ and $c^2$. . These two facts are demonstrated in the cells below, and demonstrates some severe disadvantages to Phipp&#39;s potential. We are therefore inclined to investigate Weber&#39;s potential as a model of electrodynamics. . from sympy import * t=symbols(&#39;t&#39;) m=symbols(&#39;m&#39;) c=symbols(&#39;c&#39;) r=Function(&#39;r&#39;)(t) P=Function(&#39;P&#39;)(r,t) F=Function(&#39;F&#39;)(r,t) P=(r**-1)*sqrt(1-r.diff(t)/c) F=(-1)*(P.diff(t))*((r.diff(t))**-1) pprint(simplify(P)) print() pprint(simplify(F)) ## symbolic computation of the Force law. . ______________ ╱ d ╱ c - ──(r(t)) ╱ dt ╱ ──────────── ╲╱ c ──────────────────── r(t) 2 d r(t)⋅───(r(t)) 2 ⎛ d ⎞ d dt ⎜c - ──(r(t))⎟⋅──(r(t)) + ────────────── ⎝ dt ⎠ dt 2 ──────────────────────────────────────── ______________ ╱ d ╱ c - ──(r(t)) ╱ dt 2 d c⋅ ╱ ──────────── ⋅r (t)⋅──(r(t)) ╲╱ c dt . import numpy as np from scipy.integrate import odeint, solve_ivp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D m=0.5 ## mass of second test particle c=1.0 ## speed of light constant in Weber&#39;s potential ## Kinetic Energy: we use the naive expression for vis viva. Is it correct? def T(vx, vy, vz): return m*(vx*vx+vy*vy+vz*vz)/2 ## Phipp&#39;s Potential Energy def P(x,y,z,vx,vy,vz): r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r return (r**-1)*(1-rdot/c)**0.5 ## Integrating equations of motion relative Phipp&#39;s Force Law. def phipp(t, state): x, y, z, vx, vy, vz = state r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r A=r**-2 B=(1-rdot)**0.5 C=(m- ( 2*r*rdot*((1-rdot)**0.5) )**-1 )**-1 dxdt = vx dydt = vy dzdt = vz dvxdt = (x/r)*A*B*C dvydt = (y/r)*A*B*C dvzdt = (z/r)*A*B*C return [dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt] t_span = (0.0, 1000.0) t = np.arange(0.0, 1000.0, 0.001) y0=[10, 0.3, 0, -0.2, -0.9, .1] ## initial state of the system y0=[x, y, z, vx, vy, vz] result = odeint(phipp, y0, t, tfirst=True) Energy=T(y0[3], y0[4], y0[5] ) + P(y0[0],y0[1],y0[2],y0[3],y0[4],y0[5]) print(&#39;The initial total energy T+P is equal to:&#39;, Energy) print(&#39;The luminal energy is:&#39;, m*c*c/2) print(&#39;The energy is subliminal:&#39;, Energy &lt; m*c**2 /2) r = ( y0[0]*y0[0] + y0[1]*y0[1] + y0[2]*y0[2])**0.5 rdot = ( y0[0]*y0[3] + y0[1]*y0[4] + y0[2]*y0[5] ) /r print(&#39;Phipp`s critical radius is equal to:&#39;,(m- ( 2*r*rdot*((1-rdot)**0.5) )**-1)**-1) ## N.B. Phipp&#39;s critical radius depends on the distance and velocity! print(&#39;The initial radius r and velocity r` is within Phipp`s critical distance:&#39;, r &lt; (m*c*c)**-1 ) fig = plt.figure() ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;) ax.plot(result[:, 0], result[:, 1], result[:, 2]) ax.set_title(&quot;position&quot;) ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;) ax.plot(result[:, 3], result[:, 4], result[:, 5]) ax.set_title(&quot;velocity&quot;) . The initial total energy T+P is equal to: 0.3257156133373373 The luminal energy is: 0.25 The energy is subliminal: False Phipp`s critical radius is equal to: 1.4309087883533131 The initial radius r and velocity r` is within Phipp`s critical distance: False . Text(0.5, 0.92, &#39;velocity&#39;) . import matplotlib.pyplot import pylab def rho(x,y,z): return (x*x+y*y+z*z)**0.5 v_list=[] for j in range(4000): v_list.append( (rho(result[j,0], result[j,1], result[j,2]), T(result[j,3], result[j,4], result[j,5])) ) P_list=[] for j in range(4000): P_list.append( (rho(result[j,0], result[j,1], result[j,2]), P(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5])+T(result[j,3], result[j,4], result[j,5])) ) prelist1 = list(zip(*v_list)) pylab.scatter(list(prelist1[0]),list(prelist1[1])) pylab.show() prelist2 = list(zip(*P_list)) pylab.scatter(list(prelist2[0]),list(prelist2[1])) pylab.show() .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/11/PhippPotential.html",
            "relUrl": "/fastpages/jupyter/2022/02/11/PhippPotential.html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Letter To Prof. Assis.",
            "content": "2022-02-10-Verifying Conservation of Energy with Python. . Dear Professor Assis, . I am currently studying the Weber potential $U= frac{e_1 e_2}{r} (1- frac{r&#39;^2}{2c^2})$ in python, and specifically looking at the equations of motion of an isolated two-body system. For computation i have chosen one particle to be the origin, and look to solve the equations of motion for the second particle. In computations I take $e_1=e_2=1$ and $c=1$, and the relative mass of the second particle to be $m=0.5$. (Is that mass to small?) . I am fairly confident that I have correctly integrated the equations of motion using python&#39;s odeint. . However I am not able to satisfactorily verify conservation of energy $d(T+U)=0$ along the trajectories, and I am not confident that I have the correct expression for kinetic energy $T$, i use the naive expression $T=mv^2/2$, where $v^2$ is computed in usual way as sum of squares of the velocities of the second particle of mass $m=0.5$. When I use the above expression for $T$ I find the sum $T+U$ is not constant along solutions to the equations of motion $mr&#39;&#39;=ma=F$, where $F=- hat{r} frac{dU}{dr}$ is Weber&#39;s force. . From your book on &quot;Relational Mechanics&quot; i understand that kinetic energy is more properly defined as the interaction energy of the particle with the stars at infinity. But is the naive kinetic energy $T=mv^2/2$ the correct expression for the isolated two-body system? . import numpy as np from scipy.integrate import odeint, solve_ivp import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D m=0.5 ## mass of second test particle c=1.0 ## speed of light constant in Weber&#39;s potential ## Kinetic Energy: we use the naive expression for vis viva. Is it correct? def T(vx, vy, vz): return m*(vx*vx+vy*vy+vz*vz)/2 ## Weber Potential Energy def U(x,y,z,vx,vy,vz): r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r return (r**-1)*(1-(rdot**2)/2) ## Integrating equations of motion relative Weber&#39;s Force Law. ## I think I have implemented everything correctly. The formula for rdot is from Relational Mechanics, pp.168 ## but perhaps I have the wrong formula for r&#39;&#39; and have not applied Newtons second law F=mr&#39;&#39; correctly? def weber(t, state): x, y, z, vx, vy, vz = state r=(x*x + y*y + z*z)**0.5 rdot=(x*vx+y*vy+z*vz)/r A=r**-2 B=1-(rdot*rdot)/2 C=(m-((c*c*r)**-1))**-1 dxdt = vx dydt = vy dzdt = vz dvxdt = (x/r)*A*B*C dvydt = (y/r)*A*B*C dvzdt = (z/r)*A*B*C return [dxdt, dydt, dzdt, dvxdt, dvydt, dvzdt] t_span = (0.0, 40.0) t = np.arange(0.0, 40.0, 0.001) y0=[0, 1.2, 0, 0, -0.4, .1] ## initial state of the system y0=[x, y, z, vx, vy, vz] result = odeint(weber, y0, t, tfirst=True) Energy=T(y0[3], y0[4], y0[5] ) + U(y0[0],y0[1],y0[2],y0[3],y0[4],y0[5]) print(&#39;The initial total energy T+U is equal to:&#39;, Energy) print(&#39;The luminal energy is:&#39;, m*c*c/2) print(&#39;The energy is subliminal:&#39;, Energy &lt; m*c**2 /2) r=(y0[0]*y0[0] + y0[1]*y0[1] + y0[2]*y0[2])**0.5 print(&#39;Webers critical radius is equal to:&#39;,(m*c*c)**-1) print(&#39;The initial radius r is within the Weber critical distance:&#39;, r &lt; (m*c*c)**-1 ) fig = plt.figure() ax = fig.add_subplot(1, 2, 1, projection=&#39;3d&#39;) ax.plot(result[:, 0], result[:, 1], result[:, 2]) ax.set_title(&quot;position&quot;) ax = fig.add_subplot(1, 2, 2, projection=&#39;3d&#39;) ax.plot(result[:, 3], result[:, 4], result[:, 5]) ax.set_title(&quot;velocity&quot;) . The initial total energy T+U is equal to: 0.8091666666666666 The luminal energy is: 0.25 The energy is subliminal: False Webers critical radius is equal to: 2.0 The initial radius r is within the Weber critical distance: True . Text(0.5, 0.92, &#39;velocity&#39;) . import matplotlib.pyplot import pylab def rho(x,y,z): return (x*x+y*y+z*z)**0.5 v_list=[] for j in range(4000): v_list.append( (rho(result[j,0], result[j,1], result[j,2]), T(result[j,3], result[j,4], result[j,5])) ) U_list=[] for j in range(4000): U_list.append( (rho(result[j,0], result[j,1], result[j,2]), U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5])+T(result[j,3], result[j,4], result[j,5])) ) prelist1 = list(zip(*v_list)) pylab.scatter(list(prelist1[0]),list(prelist1[1])) pylab.xlabel(&#39;distance r&#39;) pylab.ylabel(&#39;Kinetic Energy T&#39;) pylab.title(&#39;rT plot&#39;) pylab.show() prelist2 = list(zip(*U_list)) pylab.scatter(list(prelist2[0]),list(prelist2[1])) pylab.xlabel(&#39;distance r&#39;) pylab.ylabel(&#39;T+U&#39;) pylab.title(&#39;Conservation of Energy&#39;) pylab.show() ## Error. Expect to see conservation of energy T+U = constant in the second figure. However the sum T+U appears nonconstant. . Discussion: The horizontal axis is the radial distance $r$ from the origin, and the vertical axis is the energy value. We expect the second figure to be a horizontal straight line. It does appear basically flat except for blow-up behaviour at small distance. Perhaps given the relative size of the interval of integration, namely $0.001$, the total energy $T+U$ is constant within error. . Is this loss/gain of energy a defect from the odeint routine? In otherwords, is energy not conserved because of cumulative errors and approximations in the solution? . for j in range(50): print( U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5]) + T(result[j,3], result[j,4], result[j,5]) ) . 0.8091666666666666 0.8091694528769837 0.8091722560959542 0.8091750763849768 0.8091779137441633 0.8091807683256578 0.8091836401044897 0.8091865291060831 0.8091894353679061 0.8091923589396186 0.8091952998832174 0.8091982582731821 0.8092012341218966 0.8092042274175154 0.8092072382239642 0.8092102666157523 0.8092133126780814 0.8092163765069865 0.8092194582094769 0.8092225578481547 0.8092256753069924 0.8092288106302348 0.8092319638914872 0.8092351351750412 0.8092383245760144 0.8092415322004902 0.8092447570890509 0.8092480017730359 0.8092512645080137 0.8092545454217692 0.8092578446432682 0.8092611623026272 0.8092644985310876 0.8092678534609862 0.809271227118879 0.8092746194540041 0.8092780305448041 0.8092814604679077 0.8092849092969379 0.8092883771024215 0.8092918639517022 0.8092953699088504 0.8092988950345746 0.80930243938613 0.8093060030172264 0.8093095859779383 0.8093131883146094 0.8093168100697619 0.8093204512819989 0.8093241120128701 . Radius of Weber&#39;s Planetary Atomic Model . Now we consider the diameter of Weber&#39;s critical radius if the test particles $x_1$, $x_2$ are equal to a positron, electron pair. . The mass of the electron is: [ref]. . Lagrangian L=T-U . Given the conservation of energy $d(T+U)=0$ it seems natural to consider the so-called Lagrangian $L=T-U$. But what do we expect from this lagrangian? Is there any reason to believe that a &quot;minimum action&quot; principle holds for two-body systems? Does the above naive expression for $L$ actually correspond to a reasonable action functional on the state space? . L_list=[] for j in range(4000): L_list.append( (rho(result[j,0], result[j,1], result[j,2]), -U(result[j,0],result[j,1],result[j,2],result[j,3],result[j,4],result[j,5])+T(result[j,3], result[j,4], result[j,5])) ) prelist2 = list(zip(*L_list)) pylab.scatter(list(prelist2[0]),list(prelist2[1])) pylab.show() .",
            "url": "https://jhmartel.github.io/fp/fastpages/jupyter/2022/02/10/LetterToAssisWeberPotentials.html",
            "relUrl": "/fastpages/jupyter/2022/02/10/LetterToAssisWeberPotentials.html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Title",
            "content": "!pip install curver ## need install curver package. . import curver ## we load the mapping class group of genus two with one puncture ## S=curver.load(2,1) ## Below are the standard generators in Lickorish presentation, following Bell, Margalit, etc.. ## Id=S(&#39;&#39;) a=S(&#39;a_0&#39;) A=a**-1 b=S(&#39;a_1&#39;) B=b**-1 c=S(&#39;c_0&#39;) C=c**-1 d=S(&#39;d_1&#39;) D=d**-1 e=S(&#39;b_0&#39;) E=e**-1 f=S(&#39;b_1&#39;) F=f**-1 ## Ad is the adjoint action ## which replaces w2 by the w1-conjugate. def Ad(w1, w2): return w1*w2*(w1**-1) ## Translate is used to compute the adjoint action ## on a collection of curves, i.e. the pants p. def Translate(x, p): return {Ad(x,w) for w in p} ## br stands for &quot;bracket&quot; like &quot;commutator bracket&quot;. ## Thus br(x,y)=[x,y]=xyx^{-1} y^{1} in the usual group-theoretic notation def br(x,y): return Ad(x,y)*(y**-1) pant={a,b,c} zeta=a*e*c*f*b ## zeta is the order 6 element in MCG arising from chain relation. ## nu=a*e*c*f ## nu is order 10 element in MCG mu=nu**4 ## mu is order 5 element in MCG. ## The following code shows that pant and mu.pant are &quot;dual&quot; pants. #for x in pant: # for y in Translate(mu, pant): # if br(x,y)==Id: # print(&quot;The elements commute! And the curves are disjoint!&quot; ) # if br(x,y)!=Id: # print(&quot;The elements are NONcommuting. Now evaluating dual relation:&quot;, x*y*x==y*x*y) # else: pass ## xi is the steinberg symbol in our case. ## xi is obtained by joining the initial pant p with its mu translate. xi=pant|Translate(mu, pant) ## We need verify that the mu-translate of p is &quot;dual&quot; to p ## in the appropriate intersection-theoretic sense. This duality ## is nonstandard definition. #print(xi) ## important to verify that pant and the mu-translate are disjoint. ## Ad(mu,pant) is &quot;opposite pair of pants&quot; print(&quot;The mu translate of the standard pant is disjoint from pant. &quot;, pant &amp; Translate(mu, pant) == set()) print() ## Now translate the symbol xi by the powers of mu. ## The translates are not disjoint, good!, that means there is cancellation in the symmetric difference. print(&quot;The Steinberg symbol in our calculation is xi, and is the sum of the standard pant with its mu translate.&quot;) print() M0=xi M1=Translate(mu,xi) M2=Translate(mu**2,xi) M3=Translate(mu**3,xi) M4=Translate(mu**4,xi) ## The following proves that all the symbol translates are nontrivial, and there is no complete coincidence ## between the translated symbols. print(&quot;The mu translates of xi are all pairwise distinct:&quot;, M0!=M1 and M0!=M2 and M0!=M3 and M0!=M4 and M1!=M2 and M1!=M3 and M1!=M4 and M2!=M3 and M2!=M4 and M3!=M4 ) print() ## The following proves that the total chain sum of the translated symbols vanishes mod 2. ## I.e. the iterated symmetric difference of the translated symbols is equal to empty set. print(&quot;The iterated symmetric difference of the mu translates is empty.&quot;, ((((M0^M1))^M2)^M3)^M4 ==set()) print() print(&quot;The mu-orbit of xi is supported on ten curves.&quot;, 10==len(M0|M1|M2|M3|M4) ) print() print(&quot;Therefore we find I={Id, mu, mu**2, mu**3, mu**4} is a formal solution to Closing the Steinberg symbol xi in genus two.&quot;) print(&quot;&quot;) . The mu translate of the standard pant is disjoint from pant. True The Steinberg symbol in our calculation is xi, and is the sum of the standard pant with its mu translate. The mu translates of xi are all pairwise distinct: True The iterated symmetric difference of the mu translates is empty. True The mu-orbit of xi is supported on ten curves. True Therefore we find I={Id, mu, mu**2, mu**3, mu**4} is a formal solution to Closing the Steinberg symbol xi in genus two. . B0=M0|M1|M2|M3|M4 gen=(Id, a, A, b, B, c, C, d, D, e, E, f, F) gen1=(x*y for x in gen for y in gen) sample1=set(gen)|set(gen1) gen2=(x*y for x in gen for y in sample1) sample2=sample1|set(gen2) # gen3=(x*y for x in gen for y in gen2) #len(set(gen3)) len(sample2) #for word in gen1: # print( len(Translate(word, B0) &amp; B0)) . 105 . )B**-1 .",
            "url": "https://jhmartel.github.io/fp/2022/02/08/ClosingSteinbergGenusTwo.html",
            "relUrl": "/2022/02/08/ClosingSteinbergGenusTwo.html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://jhmartel.github.io/fp/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jhmartel.github.io/fp/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jhmartel.github.io/fp/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jhmartel.github.io/fp/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}